# Теперь WebKit поддерживает srcset, и это хорошо!

WebKit попал, так сказать, на первые полосы газет: наконец-то он [поддерживает
атрибут `srcset`][1]. Как глава общественной группы W3C по отзывчивым
изображениям, я уже в течение ощутимого времени попеременно то с надеждой, то с
ужасом ждал этого момент. Но получается, что новости оказались хорошими для всех
участников процесса — и в первую очередь для веб-пользователей.

Как и со всей темой отзывчивых изображений в целом, здесь все сложно — и очень
сложно постоянно выделять ценную информацию во всем количестве шума. Вот то, что
вам нужно знать.

### Что этот атрибут делает?

Как изначально предлагала спецификация, атрибут `srcset` должен позволять
разработчикам определять список источников для изображения, которые будут
выбраны исходя из плотности пикселей на дисплее пользователя:

      <img src="low-res.jpg" srcset="high-res.jpg 2x">

Ничего страшного в такой разметке нет. Переводим на человеческий язык:

“Используем _low-res.jpg_ в качестве источника этого изображения на дисплеях с
низким разрешениями и в тех браузерах, которые не поддерживают атрибут `srcset`.
Используем _high-res.jpg_ в качестве источника этого изображения на дисплеях
высокого разрешения в браузерах, которые понимают атрибут `srcset`.”

Некоторое время назад все действительно начало выглядеть страшно. В частности по
причине появления большого количества устройств с высоким разрешением,
изображения на сайте [в среднем весят почти мегабайт][2]. Теперь разработчики
могут отдавать пользователям с дисплеями с высоким разрешением retina-
изображение. В то же время, пользователи на экранах с низкой плотностью пикселей
не будут погребены под огромными изображениями с высоким разрешением, которые
забивают интернет-канал, но при это никакой разницы в изображении нет.

### А разве мы не можем делать это на JavaScript?

На поверхности `srcset` не делает ничего совсем уж особенного — он выбирает
подходящий источник из атрибута и подменяет содержимое атрибута `src` в элементе
`img`. Такую функцию — заменять значение атрибута — мы используем в JavaScript
очень давно — по крайней мере, с 90-х. Что же нам дает эта реализация?

Мы попробовали этот подход с JavaScript на сайте [BostonGlobe.com][3], который
одним из первых крупных сайтов решился применить у себя какой-нибудь вариант
техники «отзывчивых изображений». Однако из-за предзагрузки внутри нескольких
крупных браузеров (которая становится со временм все более и более агрессивной),
`src` изображения загружается задолго до того, как у нас есть малейшая
возможность применить кастомные скрипты: приходится делать два запроса на каждую
картинку, которую мы показываем на экране — что лишает смысла все предприятие. Я
[уже описал кое-что из того, что мы делали тогда][4], так что сейчас избавлю вас
от нелицеприятных деталей.

### А разве мы не можем делать это на CSS?

И да, и нет. Это можно делать довольно просто с фоновыми изображениями: для
этого нужно использовать сочетания медиазапросов, отвечающих за плотность
пикселей. `srcset` в WebKit очень похож на функцию `image-set`, которую они же
недавно включили в CSS. `image-set` позволяет вам определить список источников
для фоновых изображений и разрешений, а потом дать браузера принять решение,
которую из них лучше всего выбрат — все это вполне вам знакомо. Единственное —
до сих пор у нас не было ничего подобного для изображений, которые относятся к
_содержимому_, а не только к презентационной части.

Использовать CSS для управлением изображениями, относящимися к содержимому — по
определению плохая идея, поскольку разные части нашего сайта перестают быть
отдельными друг от друга. Такой подход вполне может работать в рамках маленькой
демо-странички, но на большом сайте вещи начнут очень быстро выходить из-под
контроля. С точки зрения девелопера будет очень невесело заставлять CMS
генерировать жуткое количество таблиц стилей с фоновыми изображениями. Еще хуже,
что браузеры будут запрашивать таблицы стилей и изображения, которые — только
если не делать это очень, очень аккуратно — пользователям совершенно не нужны.
Ну и кроме того, наши изображения становятся таким образом недоступными для
технологий, помогающих пользователям с ограниченными возможностями.

Самое близкое к полноценному решению на CSS – это подход, которые меняет
источник изображения в зависимости от значений в атрибутах data-, для этого есть
[хитрая CSS-техника][5]; к сожалению, это решение во многом только теоретическое
и может навсегда остаться на бумаге. Однако и это решение не позволяет избежать
двойного скачивания изображений с высоким и низким разрешением — то, с чем мы
столкнулись, используя JavaScript-решения. Даже если бы мы смогли применять
технику Николаса в реальных условиях, у нас была бы та же проблема, что и с
решениями на JavaScript — как разобраться с ненужным, лишним запросом.

### А пропускная способность сети?

Вне зависимости от плотности дисплея, есть ряд ситуаций, в которых
предпочтительнее показывать пользователю изображения с низким разрешением:
например, Retina MacBook Pro, который подключен к интернету через 3G или через
нестабильное вай-фай-соединение на конференции — и с той и с другой ситуацией мы
сталкивается постоянно.

`srcset` не только дает нам возможность коротко писать медиазапросы в
зависимости от разрешения, но неким образом учитывает и пропускную способность
сети. Конечно, это все погребено в жутком жаргоне спецификаций, но одна из самых
интересных сторон `srcset` — то, что этот атрибут определяется как набор
_рекомендаций_ браузеру. Браузер после этого можно использовать эвристику на
основании того, что ему известно о контексте, или пользовательские настройки — и
решить, что ему стоит скачать изображение с низким разрешением даже для retina-
дисплея: представьте себе настройку в мобильном браузере, которая позволяет
скачивать изображения высокого разрешения только тогда, когда вы подключены к
Wi-Fi или настройка, которая позволяет вам запрашивать только изображения
низкого разрешения при нестабильном соединении.

![Responsive Images][6]

_В идеале, мы хотели бы, чтобы на каждое устройство уходили только картинки,
которые соответствуют разрешению экрана устройства. Цель здесь в том, чтобы не
нагружать соединение и позволять изображениям загружаться быстрее на
соответствующем дисплее. Вот [типовой сценарий применения для отзывчивых
изображений][7]._

Это не входит в ту имплементацию `srcset`, которая появилась в WebKit сейчас, но
это открывает дорогу для их добавления без каких-либо изменений в разметке. Мы,
разработчики, можем спокойно использовать `srcset` сегодня, и эти оптимизации,
вероятно, придут в будущем — совершенно бесплатно.

### А что это означает для элемента `picture`?

А вот здесь становится интересно.

Та версия `srcset`, которая сейчас поддерживается WebKit, соответствует
первоначально предложенной спецификации `srcset` и той версии, над которой
работает [общественная группа по отзывчивым изображениям][8]. Нам
представляется, что это воплощение `srcset` — это краткий синтаксис для большого
количества медиазапросов, связанных с разрешением, с одним ключевым отличием:
браузер может менять источник изображения в зависимости от пользовательских
настроек.

Хотя эта реализация соответствуют изначательно предложенной спецификации
`srcset`, текущая спецификация пытается расширить синтаксис, чтобы работать в
ряде [сценариев][7], которые призван решить элемент `picture` — причем
спецификация использует для этого микросинтаксис, который выполняет некоторые —
но далеко не все! — функции медиазапросов.

      <img src="fallback.jpg" srcset="small.jpg 640w 1x, small-hd.jpg 640w 2x, large.jpg 1x, large-hd.jpg 2x" alt="…">

По нашему мнению, эта система разметки далеко не идеальна. Получается, что мы
можем пользоваться только эквивалентом медиазапроса `max-width`, пикселями,
жутким микросинтаксисом — и все это для того, чтобы повторить функциональность
медиазапросов. К счастью, ни веб-разработчики, ни производители браузеров не в
восторге от этого синтаксиса — и, будем надеяться, он никогда не будет
реализован.

Для того, чтобы справиться с этими сценариями, существует элемент `picture`,
который может похвастаться более гибким и более понятным синтаксисом. `picture`
использует атрибуты `media` на элементах `source` (так же, как внутри `video`).
Это позволяет нам выбирать источники изображений в зависимости от целого набора
факторов: ширина/высота окна бразуера, в пикселях или `em`, — и можно
использовать значения `min` и `max` — точно так же, как медиазапросы в CSS.

      <picture>
          <source src="med.jpg" media="(min-width: 40em)" />
          <source src="sm.jpg" />
          <img src="fallback.jpg" alt="" />
      </picture>

Спецификация `picture` была написана с учетом этого редуцированного синтаксиса
`srcset`, так что его можно использовать на элементах `source` внутри `picture`
точно так же, как и на элементах `img`.

      <picture>
          <source srcset="med.jpg 1x, med-hd.jpg 2x" media="(min-width: 40em)" />
          <source srcset="sm.jpg 1x, sm-hd.jpg 2x" />
          <img src="fallback.jpg" alt="" />
      </picture>

Вместе две системы разметки дают нам невероятную гибкость относительно того,
какие источники изображений мы отдаем пользователям в зависимости от контекста,
в котором они просматривают страницу.

### Так что это _действительно_ хорошие новости.

Именно так. Конечно, то, как именно Webkit поддерживает `srcset` не решает все
[сценарии, в которых нужно использовать отзывчивые изображения][7], по крайней
мере эта поддержка — большой шаг к решению, необходимость в котором назрела
давно: надежда есть и на то, что этим шагом все не ограничится.

Будем надеяться, что другие браузеры пойдут по стопам WebKit, станут
поддерживать эту функцию в том формате, в котором она была изначально
предложена. Чтобы оставаться в курсе событий, заглядывайте на [домашнюю страницу
общественной группы по отзывчивым изображениям][8] и в наш [аккаунт Twitter][9].

Я уже писал о проблемах с отзывчивыми изображениями и теми решениями, к которым
мы пришли, когда работали над сайтом Boston Globe, в моей [книге, которая выйдет
в серии Smashing Book][10], в главе «Проблемы и решения в отзывчивом веб-
дизайне». Почитайте ее, она вас не разочарует.

   [1]: https://www.webkit.org/blog/2910/improved-support-for-high-resolution-displays-with-the-srcset-image-attribute/
   [2]: http://httparchive.org/interesting.php?a=All&amp;l=Aug%2015%202013
   [3]: http://bostonglobe.com
   [4]: http://alistapart.com/article/responsive-images-how-they-almost-worked-and-what-we-need
   [5]: http://nicolasgallagher.com/responsive-images-using-css3
   [6]: use-case.png
   [7]: http://usecases.responsiveimages.org
   [8]: http://responsiveimages.org
   [9]: http://twitter.com/respimg
   [10]: https://shop.smashingmagazine.com/smashing-book-4.html
